<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/png" href="/favicon.ico">
    <title>Sprout</title>
</head>

<body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>

    <div style="position: absolute" id="intro"/>

    <script type="importmap">
        {
            "imports": {
                "three": "/public/three.module.js",
                "three/addons/": "./public/addons"
            }
        }
    </script>


    <script type="module">

        import * as THREE from '/public/threejs/three.module';

        import { AsciiEffect } from '/public/threejs/AsciiEffect.js';
        import { TrackballControls } from '/public/threejs/TrackballControls.js';
        import { FontLoader } from '/public/threejs/FontLoader.js';

        let camera, controls, scene, renderer, effect;

        let text, text2, pointLight1, pointLight2

        const start = Date.now();

        init();
        animate();

        function init() {

            camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
            camera.position.y = 0;
            camera.position.z = 450;

            scene = new THREE.Scene();
            scene.background = new THREE.Color( 0, 0, 0 );


            const loader = new FontLoader();
            loader.load( '/public/fonts/helvetiker_regular.typeface.json', function ( font ) {

                const shapes = font.generateShapes( ' sprout. ', 800 );
                const geometry = new THREE.ShapeGeometry( shapes );
                geometry.computeBoundingBox();
                const xMid = - 0.5 * ( geometry.boundingBox.max.x - geometry.boundingBox.min.x );

                geometry.translate( xMid, 0, 0 );

                text = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } ) );
                text.position.z = - 150;
                text.position.y = -300;
                scene.add( text );
                text2 = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } ) );
                text2.position.z = - 150;
                text2.position.y = -300;
                scene.add( text2 );
            })

            pointLight1 = new THREE.SpotLight( 0xffffff);
            pointLight1.position.set( 0, 0, 200 );
            scene.add( pointLight1 );

            pointLight2 = new THREE.PointLight( 0xffffff);
            pointLight2.position.set( 0, 0, 200 );
            scene.add( pointLight2 );

            const pointLight3 = new THREE.PointLight( 0xffffff, 0.25 );
            scene.add( pointLight3 );

            renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth, window.innerHeight );

            effect = new AsciiEffect( renderer, ' .:-+*=%@#1234567890A', { invert: true } );
            effect.setSize( window.innerWidth, window.innerHeight );
            effect.domElement.style.color = 'gray';
            effect.domElement.style.backgroundColor = 'black';
            // Special case: append effect.domElement, instead of renderer.domElement.
            // AsciiEffect creates a custom domElement (a div container) where the ASCII elements are placed.

            document.getElementById("intro").appendChild(effect.domElement)
            setTimeout(() => {
                //document.getElementById("intro").remove()
            }, 5000)

            controls = new TrackballControls( camera, effect.domElement );

            window.addEventListener( 'resize', onWindowResize );
        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );
            effect.setSize( window.innerWidth, window.innerHeight );

        }

        //

        function animate() {

            requestAnimationFrame( animate );

            render();

        }

        function render() {

            const timer = Date.now() - start;

            pointLight1.position.x = Math.sin( timer * 0.0002 )*0.5;
            pointLight1.position.y = Math.cos( timer * 0.0002 )*0.5;
            pointLight1.position.z = 1;
            pointLight1.angle = 0.5;

            pointLight2.position.y = -Math.cos( timer * 0.0001)*1000;
            pointLight2.position.z = 10;

            pointLight2.intensity = 1 - Math.abs( Math.sin( timer * 0.00001 )) * 0.5

            text.position.x = 0 - (timer * 0.1)%3500;
            text2.position.x = 2000 - (timer * 0.1 + 2000)%3500;

            controls.update();

            effect.render( scene, camera );

        }

    </script>
</body>

</html>
